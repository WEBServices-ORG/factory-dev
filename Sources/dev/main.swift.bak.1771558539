import Foundation
import ArgumentParser
import Logging

enum P {
  static let home = FileManager.default.homeDirectoryForCurrentUser
  static let root = home.appendingPathComponent("Developer")
  static let tooling = root.appendingPathComponent("tooling")
  static let templates = root.appendingPathComponent("templates")
  static let config = root.appendingPathComponent("config")
  static let staging = root.appendingPathComponent("work/.staging")
  static let workPersonal = root.appendingPathComponent("work/personal")
  static let miseDir = config.appendingPathComponent("mise")
  static let miseToml = miseDir.appendingPathComponent("mise.toml")
}

struct RuntimeError: Error, CustomStringConvertible { let description: String }
@discardableResult
func sh(_ cmd: String, cwd: URL? = nil, env: [String:String] = [:]) throws -> String {
  let p = Process()
  p.executableURL = URL(fileURLWithPath: "/bin/zsh")
  p.arguments = ["-lc", cmd]
  if let cwd { p.currentDirectoryURL = cwd }
  var e = ProcessInfo.processInfo.environment
  env.forEach { e[$0.key] = $0.value }
  p.environment = e
  let out = Pipe(); let err = Pipe()
  p.standardOutput = out; p.standardError = err
  try p.run(); p.waitUntilExit()
  let o = String(data: out.fileHandleForReading.readDataToEndOfFile(), encoding: .utf8) ?? ""
  let e2 = String(data: err.fileHandleForReading.readDataToEndOfFile(), encoding: .utf8) ?? ""
  if p.terminationStatus != 0 { throw RuntimeError(description: "\(cmd)\n\(e2)\n\(o)") }
  return o.trimmingCharacters(in: .whitespacesAndNewlines)
}

func ensureDir(_ u: URL) throws { try FileManager.default.createDirectory(at: u, withIntermediateDirectories: true) }
func write(_ u: URL, _ s: String) throws { try ensureDir(u.deletingLastPathComponent()); try s.data(using: .utf8)!.write(to: u, options: .atomic) }

func copyTree(from: URL, to: URL) throws {
  try ensureDir(to)
  let items = try FileManager.default.contentsOfDirectory(atPath: from.path)
  for it in items {
    let src = from.appendingPathComponent(it)
    let dst = to.appendingPathComponent(it)
    if FileManager.default.fileExists(atPath: dst.path) { try FileManager.default.removeItem(at: dst) }
    try FileManager.default.copyItem(at: src, to: dst)
  }
}

func replaceTokens(in url: URL, tokens: [String:String]) throws {
  let data = try Data(contentsOf: url)
  guard var s = String(data: data, encoding: .utf8) else { return }
  for (k,v) in tokens { s = s.replacingOccurrences(of: k, with: v) }
  try write(url, s)
}

enum TemplateSlot: String, CaseIterable, ExpressibleByArgument {
  case macosSwiftUI = "macos-swiftui"
  case internalLib  = "internal-lib"
  case cliTool      = "cli-tool"
}

func templatePath(_ slot: TemplateSlot) -> URL {
  switch slot {
  case .macosSwiftUI: return P.templates.appendingPathComponent("swiftui-macos-app")
  case .internalLib:  return P.templates.appendingPathComponent("internal-lib")
  case .cliTool:      return P.templates.appendingPathComponent("cli-tool")
  }
}

let log: Logger = {
  LoggingSystem.bootstrap { label in
    var h = StreamLogHandler.standardOutput(label: label)
    h.logLevel = .info
    return h
  }
  return Logger(label: "dev")
}()

@main
struct Dev: ParsableCommand {
  static let configuration = CommandConfiguration(
    commandName: "dev",
    abstract: "WEBServices local factory CLI (English-only).",
    subcommands: [Bootstrap.self, Doctor.self, New.self]
  )
}

struct Bootstrap: ParsableCommand {
  static let configuration = CommandConfiguration(abstract: "Bootstrap local factory.")
  func run() throws {
    try ensureDir(P.root)
    try ensureDir(P.tooling)
    try ensureDir(P.templates)
    try ensureDir(P.config)
    try ensureDir(P.staging)
    try ensureDir(P.workPersonal)

    try ensureDir(P.miseDir)
    if !FileManager.default.fileExists(atPath: P.miseToml.path) {
      try write(P.miseToml, """
      [tools]
      tuist = "4.0.0"
      swiftlint = "0.63.2"
      swiftformat = "0.58.0"
      """)
    }

    _ = try sh("command -v mise >/dev/null || (echo 'mise not found' && exit 1)")
    log.info("Installing tools via mise (pinned)…")
    _ = try sh("cd '\(P.miseDir.path)' && mise install")
    log.info("Done. Next: dev doctor")
  }
}

struct Doctor: ParsableCommand {
  static let configuration = CommandConfiguration(abstract: "Check health + run a smoke test.")
  @Flag(help: "Skip smoke test (fast).") var fast: Bool = false

  func run() throws {
    log.info("Checking Xcode…")
    _ = try sh("xcode-select -p")
    _ = try sh("xcodebuild -version")

    log.info("Checking toolchain…")
    _ = try sh("mise --version")
    _ = try sh("cd '\(P.miseDir.path)' && mise exec tuist -- tuist version")
    _ = try sh("cd '\(P.miseDir.path)' && mise exec swiftlint -- swiftlint version")
    _ = try sh("cd '\(P.miseDir.path)' && mise exec swiftformat -- swiftformat --version")

    if fast {
      log.info("FAST mode: smoke test skipped ✅")
      return
    }

    let name = "SmokeApp"
    let stage = P.staging.appendingPathComponent("\(name)-\(UUID().uuidString)")
    try ensureDir(stage)
    defer { try? FileManager.default.removeItem(at: stage) }

    let tpl = templatePath(.macosSwiftUI)
    guard FileManager.default.fileExists(atPath: tpl.path) else {
      throw RuntimeError(description: "Template missing: \(tpl.path)")
    }
    try copyTree(from: tpl, to: stage)

    let tokens: [String:String] = [
      "{{PRODUCT_NAME}}": name,
      "{{BUNDLE_PREFIX}}": "com.webservicesdev",
      "{{DEPLOYMENT_TARGET}}": "15.0"
    ]
    try replaceTokens(in: stage.appendingPathComponent("Project.swift"), tokens: tokens)
    try replaceTokens(in: stage.appendingPathComponent("Sources/App/ContentView.swift"), tokens: tokens)
    let testFile = stage.appendingPathComponent("Tests/AppTests/{{PRODUCT_NAME}}Tests.swift")
    if FileManager.default.fileExists(atPath: testFile.path) {
      try replaceTokens(in: testFile, tokens: tokens)
    }

    let stagePath = stage.path
    _ = try sh("cd '\(stagePath)' && mise trust")
    _ = try sh("cd '\(stagePath)' && mise install")
    _ = try sh("cd '\(stagePath)' && mise exec tuist -- tuist generate")

    log.info("Smoke: xcodebuild test…")
    _ = try sh("cd '\(stagePath)' && xcodebuild test -scheme \(name) -destination 'platform=macOS' -quiet")

    log.info("Doctor ✅ (including smoke test)")
  }
}

struct New: ParsableCommand {
  static let configuration = CommandConfiguration(abstract: "Create a new project from a template slot.")
  @Argument(help: "Template slot (macos-swiftui / internal-lib / cli-tool).") var slot: TemplateSlot
  @Argument(help: "Project name (e.g. DemoApp).") var name: String
  @Option(help: "Bundle ID prefix.") var org: String = "com.webservicesdev"
  @Option(help: "Deployment target (macOS).") var target: String = "15.0"
  @Option(help: "Output directory (default: ~/Developer/work/personal/<Name>).") var dir: String?

  func run() throws {
    let tpl = templatePath(slot)
    guard FileManager.default.fileExists(atPath: tpl.path) else {
      throw RuntimeError(description: "Template slot not found: \(tpl.path)")
    }

    let out: URL = {
      if let dir { return URL(fileURLWithPath: (dir as NSString).expandingTildeInPath) }
      return P.workPersonal.appendingPathComponent(name)
    }()

    if FileManager.default.fileExists(atPath: out.path) {
      throw RuntimeError(description: "Destination exists: \(out.path)")
    }

    let stage = P.staging.appendingPathComponent("\(name)-\(UUID().uuidString)")
    try ensureDir(stage)

    do {
      try copyTree(from: tpl, to: stage)

      let tokens: [String:String] = [
        "{{PRODUCT_NAME}}": name,
        "{{BUNDLE_PREFIX}}": org,
        "{{DEPLOYMENT_TARGET}}": target
      ]
      try replaceTokens(in: stage.appendingPathComponent("Project.swift"), tokens: tokens)
      try replaceTokens(in: stage.appendingPathComponent("Sources/App/ContentView.swift"), tokens: tokens)

      // optional tokenized files
      let optionalFiles = [
        "mise.toml",
        ".github/workflows/ci.yml",
        "factory/git-hooks/pre-commit",
        "Tests/AppTests/{{PRODUCT_NAME}}Tests.swift"
      ]
      for f in optionalFiles {
        let u = stage.appendingPathComponent(f)
        if FileManager.default.fileExists(atPath: u.path) {
          try replaceTokens(in: u, tokens: tokens)
        }
      }

      let stagePath = stage.path
      _ = try sh("cd '\(stagePath)' && mise trust 2>&1 || true")
      _ = try sh("cd '\(stagePath)' && mise install 2>&1 || true")
      _ = try sh("cd '\(stagePath)' && mise exec tuist -- tuist generate 2>&1 || true")
      _ = try sh("cd '\(stagePath)' && git init 2>&1")

      // install git hook (after git init)
      let hookDir = stage.appendingPathComponent(".git/hooks")
      try ensureDir(hookDir)
      let srcHook = stage.appendingPathComponent("factory/git-hooks/pre-commit")
      let dstHook = hookDir.appendingPathComponent("pre-commit")
      if FileManager.default.fileExists(atPath: srcHook.path) {
        if FileManager.default.fileExists(atPath: dstHook.path) { try FileManager.default.removeItem(at: dstHook) }
        try FileManager.default.copyItem(at: srcHook, to: dstHook)
        _ = try sh("chmod +x '\(dstHook.path)'")
      }

      _ = try sh("cd '\(stagePath)' && git add .")
      let env = [
        "GIT_AUTHOR_NAME": "WEBServices Factory",
        "GIT_AUTHOR_EMAIL": "admin@webservicesdev.com",
        "GIT_COMMITTER_NAME": "WEBServices Factory",
        "GIT_COMMITTER_EMAIL": "admin@webservicesdev.com",
        "GIT_AUTHOR_DATE": "2000-01-01T00:00:00Z",
        "GIT_COMMITTER_DATE": "2000-01-01T00:00:00Z",
      ]
      _ = try sh("cd '\(stagePath)' && git commit -m \"Initial commit\"", env: env)

      try ensureDir(out.deletingLastPathComponent())
      try FileManager.default.moveItem(at: stage, to: out)
      log.info("Created ✅ \(out.path)")
    } catch {
      try? FileManager.default.removeItem(at: stage)
      throw error
    }
  }
}
